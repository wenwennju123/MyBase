堆
    堆结构就是用数组实现的完全二叉树结构
    完全二叉树中如果每棵子树的最大值都在顶部就是大根堆
    完全二叉树中如果每颗字数的最小值都在顶部就是小根堆
    堆结构的 heapInsert 和 heapify 操作
    堆结构的增大与减少
    优先级队列结构就是堆结构

C++中可以重写比较运算符，类比Java中重写比较器方法
    public static class IdDescendingComparator implements Comparator<Student>{
        @Override
        public int compare(Student o1, Student o2){
            return o2.id - o1.id;
        }
    }

比较器的使用
    比较器的实质就是重载比较运算符
    比较器可以很好的应用在特殊标准的排序上
    比较器可以很好的应用在根据特殊标准结构的排序上
    就是可以自定义比较规则

桶排序思想下的排序
    计数排序
    基数排序
分析：
    桶排序思想下的排序都是不基于比较的排序
    时间复杂度为O(N)，额外空间复杂度是 O(M)
    应用范围有限，需要根据样板的数据状况，满足桶的划分
    桶的设计比较关键，部分数据情况下有较好的发挥

排序算法的稳定性及其汇总：
    同样的个体之间，如果不因为排序而改变相对次序，就是这个排序是由稳定性的，否则就没有
    不具备稳定性的排序：
        选择排序，快速排序，堆排序
    具备稳定性的排序：
        冒泡排序，插入排序，归并排序，一切桶排序思想下的排序
    目前没有找到事件复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序

注意：
    不基于比较的排序，比较容易做到稳定性
    快排常数项低，实际数据测试中往往表现最好
    实际开发中：优先选择快速排序，空间不足堆排序，想要稳定选归并排序

    基础类型的稳定性没有意义，故选择没有稳定性且速度快的快排
    当排序对象是基本类型还是引用类型，需要根据具体数据情况来选择使用不同的排序算法

总结：           时           空           稳
    选择       O(N2)        O(1)          N
    冒泡       O(N2)        O(1)          Y
    插入       O(N2)        O(1)          Y
    归并       O(NlogN)     O(N)          Y
    快排       O(NlogN)     O(logN)       N
    堆         O(NlogN)     O(1)          N

避坑：
    归并排序的额外空间复杂度可以变为O(1),但是具体实现非常困难，可以了解 归并排序的内部缓存法
    原地归并排序 是负面的，会让归并排序的事件复杂度变为O(N2)
    快速排序可以做到稳定性问题，但是十分困难，可以了解 O1 stable sort
    所有所谓的改进都不重要，因为目前没有找到事件复杂度O(N*logN)，额外空间复杂度O(1)，又稳定的排序
    坑题：奇数放在数组左面，偶数放在数组右面，还要求原始的相对次序不变，

数据结构：
	分类：
		连续型数据结构（数组，在内存中是连续的，起始地址，每个元素的大小，偏移量）
		非连续型数据结构 也叫 跳转型数据结构（单链表，二叉树，图。。。）
		跳转+连续（线性 非线性）

	连续结构需要维持连续结构，增加元素或删除元素代价很大











































