SpringCloudAlibaba

软件版本：
	spring cloud alibaba 2022.0.0.0-RC2
	spring boot 3.x
	JDK20

核心内容：
	Nacos服务注册与发现
	Nacos服务配置中心
	OpenFeign与负载均衡
	（Dubbo协议相较于gRPC与Http实现RPC的优点）
	（DubboSpringCloud的集成与负载均衡）
	微服务网关 Spring Cloud GateWay
	（Netty协议，WebFlux的强大之处）
	（Reactor下的自定义全局异常处理）
	（自定义路由断言工厂）
	系统流控Sentinel
	分布式事务解决方案 Seata
	调用链跟踪技术 Skywalking，ES
	消息系统整合技术Spring Cloud Stream，RocketMQ


***************************************************************************************************
Spring Cloud 简介
	官网 spring.io/projects/spring-cloud
	老项目要维护可能要用到Spring Cloud Netflix 网飞的，现在已经停止维护。也叫springcloud一代
	springcloud alibaba 也叫springcloud二代

********
重要：版本关系
SpringBoot3.0 和 springBoot 2.7-2.4 和 2.4及以下 之间版本变化较大。老项目相关springboot版本依旧停留在2.4一下。
    为满足新老需求。版本分界线分别以springboot3.0  springboot2.4
	官方同时维护了 2022.x 2021.x 2.2.x三个分支。
	使用新特性，无需跨分支升级，需要选择对应的版本。

2022.x分支
	适配 springboot3.0 springcloud 2022.x 版本及以上的版本

2021.x分支
	适配 springboot2.4 springcloud 2021.x 版本及以上

2.2.x分支
	适配 springboot2.4 以下的版本

springboot3.x的巨大变化：
	JDK 17+
	Spring 6.0  同样相比5.0变化巨大
	Tomcat 10
	JakartaEE9 尽可能兼容Jakarta10
	IDEA 2022.2+

JDK
	从2019年开始 Oracle官宣
	JDK8之前及 JDK8u202 之前 免费
	JDK8u211 之后开始收费
	JDK9 JDK10 全版本免费
	JDK11 免费至 11.0.2
	JDK12-16 商用收费
	JDK 17-20 全版本（二进制版本）免费

SpringCloudAlibaba 组件之间的版本兼容关系(组件不一定是最新版)
	2022.0.0.0-RC2
	Sentinel 1.9.6
	Nacos 2.2.1
	RocketMQ 4.9.4
	Seata 1.7.0

********
软件准备：
	JDK20
	IDEA2023
版本关系：

2023.x branch: Corresponds to Spring Cloud 2023 & Spring Boot 3.2.x, JDK 17 or later versions are supported.
2022.x branch: Corresponds to Spring Cloud 2022 & Spring Boot 3.0.x, JDK 17 or later versions are supported.
2021.x branch: Corresponds to Spring Cloud 2021 & Spring Boot 2.6.x. JDK 1.8 or later versions are supported.
2020.0 branch: Corresponds to Spring Cloud 2020 & Spring Boot 2.4.x. JDK 1.8 or later versions are supported.
2.2.x branch: Corresponds to Spring Cloud Hoxton & Spring Boot 2.2.x. JDK 1.8 or later versions are supported.
	
***************************************************************************************************
生产者与消费者的思想：
	商品管理调用库存管理
	采购管理调用仓储管理
	用户管理调用订单管理
	...

********
额外了解
	Hibernate 通过在Java的bean上添加注解，自动见表
	类上添加 
		@Entity 
		@JsonIgnoreProperties({"hibernateLazyInitializer", "handler", "fieldHandler"})
	字段上添加 @Id表示主键 @GeneratedValue(strategy = GenerationType.IDENTITY) 设置自增
		也可以设置 .UUID
	Hibernate对于对象的查询默认开启了延迟加载策略
		添加上述注解避免了因查询时，延迟加载首次获取不到对象导致返回空对象造成NPE

JPA
	spring.framework.data.jpa.repository.JpaRepository

	public Interface DepartRepository extends JpaRepository<Depart, Integer>{}
	框架通过javassist动态代理生成业务无关的基础代码

	直接在Service的impl中，注入repository对象，并调用生成好的方法即可，简单快速

********
生产环境下的常用Conrtoller路径配置
通常在类上配置
	@RequestMapping("/uri")

	类上的常用方法通常配置 ("/")
	先请求方式不同POST GET DELETE PUT来进行区分
	对于相同的请求类型，通过uri进行区分，uri携带不同的参数，匹配不同的方法

********
spring的配置
	端口号
	JPA
	数据源

spring:
  jpa:
    #指定是否在Spring容器启动时创建表
    generate-ddl: true
    #指定是否在控制台显示sql语句
    show-sql: true
    #指定应用重启时，不会重新更新表，将原来的覆盖
    hibernate:
      ddl-auto: none

spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Shanghai&useUnicode=true
    username: root
    password: Lbw151290007

  #配置日志
logging:
  pattern:
    #配置控制台的日志输出格式
    console: level-%level %msg%n
  level:
    #控制springboot启动时显示的日志级别
    root: info
    #控制hibernate运行时的日志级别
    org.hibernate: info
    #控制自己的改包下的代码的日志级别
    com.leowork.provider8081: debug
    #在show-sql为true时显示sql的动态参数值
    org.hibernate.type.descriptor.sql.BasicBinder: trace
    #在show-sql为true时显示查询结果
    org.hibernate.type.descriptor.sql.BasicExtractor: trace

********
测试用谷歌浏览器插件
	Restlet Client
	使用改网页模拟发送请求，可以指定url与携带的参数和类型
	是便捷的发送json数据去测试的方法

********
消费者consumer 需要调用生产者provider 的方法
	（测试演示）使用Rest Template
	（HttpClient ---->   WebClient ----> @HttpExchange  ----->  OpenFegin）

使用配置类，创建RestTemplate
调用RestTemplate的方法，提供 url 请求携带的类型与 响应要返回的类类型，以及url中携带的参数（可变参）
	//增删改同理 删改返回void	
    @PostMapping("/save")
    public boolean saveHandle(@RequestBody Depart depart) {
        String url = SERVICE_PROVIDER + "/save";
        return Boolean.TRUE.equals(restTemplate
                .postForObject(url, depart, Boolean.class));
    }
	//查 实体类
    @GetMapping("/get/{id}")
    public Depart getHandle(@PathVariable Integer id){
        String url = SERVICE_PROVIDER + "/get/" + id;
        return restTemplate.getForObject(url, Depart.class);
    }
	//查 集合<实体类>
    @GetMapping("/list")
    public List<Depart> getHandle(){
        String url = SERVICE_PROVIDER + "/list";

        ResponseEntity<List<Depart>> responseEntity = restTemplate.exchange(
                url,
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference<List<Depart>>() {}
        );

        return responseEntity.getBody();
    }

本质 使用exchange 进行远程http访问，处理请求体，获得数据


***************************************************************************************************
服务注册中心
Nacos

********
生产者 消费者
	如果生产者挂了，消费者也无法使用。生产者存在单点问题。
	解决方法，建立生产者集群。那么就需要考虑消费者如何访问的问题，
	引入负载均衡，路由的思想。

客户端到消费者之间的是 GateWay
消费者到生产者之间的是 Nacos(Alibaba)、Zookeeper(Dubbo)、Eureka(Netfix)、Consul等中间件
	以前用过Nginx，SpringcloudAlibaba使用Nacos注册中心

********
注册中心：
	所有的提供者将自己提供的服务的名称以及自己主机的详情，
	包括IP，服务端口，版本等。写入到另一台主机的一个列表中。
	这台主机称为服务注册中心，这个表叫做服务注册表。
	所有消费者需要调用微服务时 exchange，其会从注册中心首先将服务注册表下载到本地，
	然后根据消费者本地设置好的负载均衡策略，从中选择一个服务提供者（生产者）进行调用。
	这个过程叫做服务发现
	如果一台生产者挂掉，对应的服务注册表中（定时定期）该服务会消失。
	如果正好遇到挂掉，则依据策略自动重试

********
Nacos注册中心
	官网 https://nacos.io/
	一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台

云原生应用：
Cloud Native
	简单来说就是SaaS，运行在IaaS，PaaS上的SaaS
	充分应用云端的弹性能力，分布式能力
	DevOps 开发and运维
	CD 持续化交付
	CI 持续化集成
	容器化 docker
	云原生 = 微服务 + DevOps + CI + CD + 容器化

********
架构解析
	Dynamic Naming and Configuration Service
	以 服务Service 为中心的现代应用架构
	一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台

Nacos sidecar 支持多语言的异构模块 例如go python

NameServer 支持 dns vip address-server 

OpenAPI 支持http dns udp tls

核心服务 Config Service   Naming Service
	ConfigService的一致性采用的是 rdbms based关系型数据库
	NamingService的一致性采用的是 priv-raft 定制的raft算法

Navos Core

Nacos Cluster Nacos集群

Consistency Protocol 一致性协议 
	支持 priv-raft定制的raft协议 sync renew同步更新 rdbms based关系型数据库

raft算法
	领导者选举：Raft 算法将节点分为三种角色：领导者（Leader）、跟随者（Follower）和候选人（Candidate）。
		在 Raft 中，节点通过选举产生唯一的领导者，领导者负责处理客户端请求。
	日志复制：Raft 算法通过日志复制机制确保所有节点上的日志条目保持一致。
		领导者负责向其他节点复制日志，并在大多数节点写入成功后提交日志。
	领导者心跳：领导者定期发送心跳消息给跟随者，用于维持自己的领导地位。
		如果跟随者长时间未收到领导者的心跳消息，会触发新一轮领导者选举。
	安全性：Raft 算法确保了安全性，即使在网络分区或节点故障的情况下，也能保持系统的一致性和可用性。
	容错性：Raft 算法具有良好的容错性，能够应对节点故障、网络分区等异常情况，保证系统的可靠性和稳定性。

Nacos Console

Nacos依赖Java环境运行，其本身是使用SpringBoot开发的

********
下载与配置与使用
	依照alibaba的组件版本，建议使用 2.2.1的Nacos

配置
	修改 conf目录下的 application.properties
	需要指定鉴权 自定义密钥。取代原来的公开默认值，值随意
	nacos.core.auth.plugin.nacos.token.secret.key

修改
	nacos.core.auth.enabled=true
	nacos.core.auth.server.identity.key=1234567890
	nacos.core.auth.server.identity.value=0987654321
	nacos.core.auth.plugin.nacos.token.secret.key=  长度大于32的可见字符串

其他设置
	server.servlet.contextPath=/nacos

	server.error.include-message=ALWAYS

	server.port=8848
	
	db.pool.config.connectionTimeout=30000

	db.pool.config.validationTimeout=10000

	db.pool.config.maximumPoolSize=20

	db.pool.config.minimumIdle=2

启动
	sh startup.sh -m standalone
	/bin/startup.cmd -m standalone
	默认启动都是集群模式

"nacos is starting with standalone"

         ,--.
       ,--.'|
   ,--,:  : |                                           Nacos 2.2.1
,`--.'`|  ' :                       ,---.               Running in stand alone mode, All function modules
|   :  :  | |                      '   ,'\   .--.--.    Port: 8848
:   |   \ | :  ,--.--.     ,---.  /   /   | /  /    '   Pid: 13664
|   : '  '; | /       \   /     \.   ; ,. :|  :  /`./   Console: http://192.168.214.1:8848/nacos/index.html
'   ' ;.    ;.--.  .-. | /    / ''   | |: :|  :  ;_
|   | | \   | \__\/: . ..    ' / '   | .; : \  \    `.      https://nacos.io
'   : |  ; .' ," .--.; |'   ; :__|   :    |  `----.   \
|   | '`--'  /  /  ,.  |'   | '.'|\   \  /  /  /`--'  /
'   : |     ;  :   .'   \   :    : `----'  '--'.     /
;   |.'     |  ,     .-./\   \  /            `--'---'
'---'        `--`---'     `----'

2024-06-12 14:50:01,245 INFO Tomcat initialized with port(s): 8848 (http)

2024-06-12 14:50:01,331 INFO Root WebApplicationContext: initialization completed in 2230 ms

2024-06-12 14:50:04,409 INFO Adding welcome page: class path resource [static/index.html]

2024-06-12 14:50:04,717 WARN You are asking Spring Security to ignore Ant [pattern='/**']. This is not recommended -- please use permitAll via HttpSecurity#authorizeHttpRequests instead.

2024-06-12 14:50:04,718 INFO Will not secure Ant [pattern='/**']

2024-06-12 14:50:04,733 INFO Will secure any request with [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@511f5b1d, org.springframework.security.web.context.SecurityContextPersistenceFilter@481558ce, org.springframework.security.web.header.HeaderWriterFilter@259b85d6, org.springframework.security.web.csrf.CsrfFilter@4215e133, org.springframework.security.web.authentication.logout.LogoutFilter@17043b04, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@7f353a0f, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@7c0f28f8, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@31f295b6, org.springframework.security.web.session.SessionManagementFilter@554188ac, org.springframework.security.web.access.ExceptionTranslationFilter@5ccb85d6]

2024-06-12 14:50:04,752 INFO Exposing 1 endpoint(s) beneath base path '/actuator'

2024-06-12 14:50:04,784 INFO Tomcat started on port(s): 8848 (http) with context path '/nacos'

2024-06-12 14:50:04,805 INFO Nacos started successfully in stand alone mode. use embedded storage

2024-06-12 14:54:15,895 INFO Initializing Servlet 'dispatcherServlet'

2024-06-12 14:56:01,637 INFO Completed initialization in 1 ms

如上 显示了端口，路径，以及使用了内嵌的存储（需要配置为自定的）

登录
	localhost:8848/nacos
	用户名密码默认都是 nacos

********
将provider注册到nacos服务器

	Alibaba 2023.x 分支支持 Spring Cloud 2023.x 和 Spring Boot 3.2.x 至少 JDK 17 
	<spring.cloud.version>2023.0.0</spring.cloud.version>
    <spring.cloud.alibaba.version>2023.0.1.0</spring.cloud.alibaba.version>

添加springcloud依赖
    <dependencyManagement>
        <dependencies>
		    <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>${spring.cloud.alibaba.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring.cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>	

添加nacos discovery依赖
	    <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>

在配置文件中对nacos进行配置

spring:
  #配置nacos
  application:
    #该微服务的名称
    name: depart-provider
  cloud:
    nacos:
      #nacos注册中心地址及用户名密码
      discovery:
        username: nacos
        password: nacos
        server-addr: localhost:8848

日志：注册成功提示
	level-INFO nacos registry, DEFAULT_GROUP depart-provider 192.168.214.1:8081 register finished

Nacos页面：
	服务列表改为 public
	取消命名空间的隔离（暂时）
	临时实例 true 健康状态 true

********
将consumer注册到nacos
	pom依赖添加相同
	spring配置基本一致

注意；
	修改原来consumer的controller调用producer的代码，将原来直连的url路径进行修改
	直连：SERVICE_PROVIDER = "http://localhost:8081/provider/depart";

修改为微服务的方式 -> 变为提供微服务的服务名称
	String SERVICE_PROVIDER = "http://depart-provider/provider/depart";
	
在原来的template上添加注解
	@LoadBalanced
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }

@LoadBlanced表示采用负载均衡的方式调用

********
添加负载均衡依赖
	新版CloudAlibaba 摒弃了旧版的网飞的Netflix Ribbon
	替代：Spring Cloud LoadBalancer
	更加灵活，扩展性更强

添加依赖
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-loadbalancer</artifactId>
        </dependency>

********
临时关闭，让该应用不被nacos discovery发现
在application中配置

spring.cloud.nacos.discovrery.enabled: false

********
代码中动态获取注册表的数据
	在nacos的pc控制台上可以看到服务列表
	在代码中也可以获取

注入框架提供的 发现客户端对象
    @Resource
    private DiscoveryClient discoveryClient;

controller方法
	return discoveryClient.getServices()

返回List<Service>
    根据服务名称可以获取对应的服务实例 返回 Instances
    然后根据instance实例可以获取 ServiceId Host Port Uri等信息

********
注册表缓存

关闭nacos  cmd运行 shutdown 即可

服务在启动后，当发生调用时，会自动从nacos注册中心下载并缓存注册表到本地。
	即使Nacos所在服务器宕机，消费者依旧可以调用到提供者。
	不过此时不可以再进行新的服务注册了，缓存中的列表也无法更新，直到nacos恢复。

********
临时实例和持久实例
	区别：存储位置和健康检测机制不同

	临时实例：默认情况下，服务实例仅仅会注册到Nacos内存，不会持久化到Nacos硬盘上。
		健康检测机制为Client。Client主动向server上报其健康状态，默认心跳间隔为5秒。
		15秒内server未收到Client心跳，则会将其标记为不健康。在30秒内若收到了client
		心跳，则重新恢复为健康状态。否则将该实例从server端内存清除。
	持久实例：服务实例不仅会注册到Nacos内存，同时也会被持久化到Nacos磁盘。
		健康检测机制为server模式，即server会主动去检测client的精神状态。
		默认每20s检测一次，检测失败后服务实例会被标记为不健康状态。
		但不会被清除，因为其是持久化在硬盘上的。
	持久实例配置
	spring.cloud.nacos.discovery.ephemeral: false

大多数情况下：使用临时实例。
	原因：云端具有弹性，流量增加时，自动扩容。流量缩减时，自动缩容，销毁内存中的实例更快。

默认，临时实例存储在 nacos/naming/public 目录下，微服务结束或不健康过久，被销毁。

当微服务关闭后，nacos上的持久化实例并不会被销毁，删除（注销）是比较费时费力的。
	需要提交DELETE请求，传参ip port 和 服务名serviceName 和用户名用户密码

********
持久实例配置与持久化到外置MySQL（参考）

默认情况下，nacos使用的是内嵌的嵌入式数据库 durby-data
	但嵌入式数据库不方便观察数据存储的基本情况

引入外置数据库MySQL
	要求 版本 5.6.5+，只支持mysql

初始化mysql数据库，初始化文件 mysql-schema.sql
	可以手动添加建表语句
	CREATE DATABASE IF NOT EXISTS `nacos_config`;
	USE `nacos_config`;

修改 conf/application.properties文件，增加支持mysql数据源。需要url，用户名和密码

spring.datasource.platform=mysql
spring.sql.init.platform=mysql

db.num=1   #是支持多数据库的 多个数据库从0开始计数
db.url.0=jdbc:mysql://ip:port/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true
db.user.0=username
db.password.0=password

这样单机模式下启动nacos，原本写入嵌入式数据库的数据就写入了mysql

而当集群搭建nacos时，就需要保证多台nacos之间的数据一致性。写入外置数据库就是必要的。
	就是一致性协议 Consistency Protocol 的 rdbms based 
	默认使用的内嵌durby，保持一致性使用的就是 priv-raft算法。不建议实际运用到生产环境中!

启动nacos
	启动日志最下会显示use external storge 意为使用外部数据源


************************
Nacos集群搭建与CAP 重点
	集群将提高系统的可用性，容灾能力。

举例：本机，nacos-cluster。复制三分nacos 分别设置不同的端口号

配置：cluster.conf
注意：需要填写真实的ip地址，节点。端口号 并且端口号数字不可以连续，留给系统启动使用

192.168.1.6:8849
192.168.1.6:8851
192.168.1.6:8853

集群中每个单体都会配置所有集群的ip和端口（cluster.conf文件），
	注意修改 application.properties文件中端口

默认启动就是集群启动，逐一选择所有nacos的 startup启动即可
	启动成功日志： started successfully in cluster mode, use external storage

在nacos后台管理页面，集权管理中也可以看到响应的节点。

集群部署：
	如果直接在微服务和nacos的配置文件中编写ip地址和端口号，是十分危险的。
	采用 http://nacos.com:port/openAPI + SLB 模式
	采用内网 SLB ，不可以暴露到公网以免发生危险，高可读性且更换ip方便

实现
	DNS(nacos.com) --nginx--> SLB(intranet) ---> nacos cluster(Ip1, Ip2, Ip3, ...)

对外只暴露域名，内部使用负载均衡完成集群架构


************************
集群数据一致性CAP策略 重点

Nacos(Alibaba) ----- 默认 AP 支持 CP 牺牲可用性，保证数据一致性
Zookeeper(Dubbo) ------CP 不容忍不一致，牺牲可用性来保证数据的一致性。分区发生时，系统会拒绝一部分请求来保证一致性
Eureka(Netfix)------AP 容忍短暂数据不一致，优点保证服务高可用。分区发生时，系统依旧可以供服务，但可能出现不一致的情况。


********
父子工程--Maven

父工程为springboot工程，子工程交由maven工程管理
优势：父工程可以统一管理依赖，插件和配置。子工程可以共享并继承这些，实现统一的构建管理
	当子工程出现额外的需求，可以单独覆盖某个依赖，或配置。
	并且可以建立明确的层级关系，方便功能组织结构的搭建。

新建，new model ---> maven Archetype 
	选择 partent 指定父工程

父工程的 pom 文件中会添加 <modules> 表明其子工程都有哪些
子工程的 pom 文件中会添加 <parent> 表明其父工程指向，包括pom中的局部参数也可以读取到父工程中的

********
nacos中的数据模型

Nacos数据模型Key 由三元组唯一确定，Namespace命名空间默认是空串，公共命名空间是public，分组默认是DEFAULT——GROUP

namespace --- group ---- service/DataId

注意：默认的公共命名空间 名字是 public 但是值（命名空间ID）是 空串


************************
服务隔离 重点

使用 namespace 和 group 完成不同服务间的隔离和分级（演示 provider服务提供的相同）

public + DEFAUT_GROUP + 8081
public + MY_GROUP + 8082
hello + MY_GROUP + 8083

可以使用nacos的pc后台创建命名空间
	命名空间ID 交由系统生成，手动填写命名空间名称以及描述
	交由后台的是 命名空间ID。

而nacos切换命名空间则需要点击列表上方 public|hello|... 完成切换

微服务provider中指定：
spring:
	cloud:
		nacos:
			discovery:
				server-addr:
				username:
				password:
				group:		组名
				namespace:  命名空间ID


消费者选择策略：
	服务隔离！
	消费者只能消费 同组 的服务

命名空间主要用来分割不同的环境，不同的业务。

分组常用来隔离消费者，实现选择性，分类别的消费


************************************************************************************************
SpringCloudConfig配置中心

在集群中每一台主机的配置文件都是相同的，对配置文件的更新和维护至关重要。
配置中心就是将集群中每个节点的配置文件交由配置中心同一管理。

相关产品：SpringCloud Config
		Zookeeper
		Apollo
		Disconf（百度 已经停止维护）
		Nacos（Alibaba）

远程配置

********
SpringCloud Config配置中心工作原理


			远程库(GitHub 或 私有仓库GitLab cluster)
							|
							|
				Config Server cluster
							|
							|
				  Nginx cluster + vip


Config Client1        Config Client2        Config Client3


		SpringCloudBus 消息总线系统 + MQ（SpringCloud只支持RabbitMQ和Kafka）

目前使用最多的MQ是 RocketMQ


开发人员修改配置是：
	修改远程库中的配置文件，ConfigCLient是不知道发生变更的。
	
	还需要向ConfigClient中提交POST请求，用来让Client更新配置。
	这个请求就是 bus-refresh
	然后ConfigClient再去向ConfigServer请求，更新相应的配置文件。
	每一个Client可能代表不同的微服务模块，都有各自的不同配置。

	每一个Client都需要连接上消息总线系统。
	当一个Client接收 bus-refresh请求后，将更新配置广播到消息总线系统。
	消息总线通知其他的ConfigClient，让他们去向Server更新配置。

弊端：
	1、云端配置更新后，Client并不知道。必须要提交请求去触发。更新不具有实时性，无法自动感知。
	2、消息总线向其他Client广播去更新是强制的，即使有些Client的配置无需更新，也会去发送更新请求。
		如果消息总线上链接有大量的Client，这些Client就会发送大量的请求给Server。
		占用大量系统性能。存在羊群效应。
	3、架构过于复杂，有多个其他中间件集群同时运作，容易产生性能瓶颈。

以上是重大弊端，很少使用


********
Apollo配置中心工作原理


Config Service Cluster-----数据库 DataBase DBMS ----Admin Service Cluster 实际执行修改操作
（作为Eureka Client）									（作为Eureka Client）
			|													|
			|													|
		   注册	--------	Eureka Cluster 注册中心  --------  注册
									|
								 服务发现
									|
						Meta Server Cluster（作为Eureka Client）


	ConfigClient	ConfigClient	ConfigClient                 Portal入口（用户管理配置文件的前端）

优点：
	更新是实时的，自动感知配置文件更新，Eureka注册了每个Client需要哪个配置。哪个改了给哪个更新。
不足：
	1、架构依旧比较复杂，上述途中MetaServer以及向上部分属于其内部，核心是eureka，剩下自动配置。
	只需要管理好数据库以及CLient。
	2、配置文件支持类型太少，只支持 xml text properties。不支持json！和yml


********
Nacos配置中心工作原理


			外置MySQL


		ConfigServer Cluster(Nacos)
		同样作为变更配置文件的入口


Config Client       Config  Client		 Config  Client

优点：
	架构简单，操作便捷
	实时更新自动感知。
	不会触发羊群效应
	支持文件类型更多，支持JSON YAML
	在nacos管理后台即可 导入 创建 管理配置文件
		设置group 归属应用等
		操作便捷

使用：
	配置 nacos-config依赖
		只要配置了nacos-config依赖，就相当于成为了配置中心的Config Client。
		Config Client通知自动感知配置中心中 相应 配置文件的更新
	在nacos控制台中建立配置文件即可

支持：TXT JSON XML YAML HTML Properties

********
Zookeeper配置中心工作原理（与上面三个区别较大）
	Zookeeper  是分布式协调服务器，协调各个组件，各个系统间的一致性。
	在分布式系统中作用不亚于Redis(NoSQL)

				Config Server Cluster
   Zookeeper        Zookeeper        Zookeeper       ------>  Znode 少量的配置文件存储在自己的数据库


Config CLient      Config CLient      Config CLient


Zookeeper拥有自己的控制台后端，用户使用界面来修改配置信息
	由于Config Server 也是集群，相互之间存在一致性问题
	

Zookeeper配置中心与其他的较大区别就是没有第三方的服务器来存储配置。
	而是存储在自己的Znode中。
	znode是一种树形结构，节点分为四种类型，特性。来让他们发挥不同的作用。
	底层有一个监听机制 watcher。 监听znode中哪些发生了变更
	当配置中心中的配置数据发生了变更，Config Client也可以自动感知并触发回调，更新配置。


************************
数据一致性问题
	首先是分析哪里出现了一致性问题，是配置中心还是注册中心
	不存储数据的就不存在数据一致性问题。

	配置中心中的配置数据一般都是持久化在第三方服务器的，例如DBMS，Git远程仓库
	这些配置中心的Server中根本就不存在数据，所以他们的集群中也不存在数据一致性问题。

但Zookeeper，其作为配置中心，配置数据是存放在自己本地的，节点会存在一致性问题。
	Zookeeper采用的是 CP模式 牺牲可用性保证一致性。
		也就是 未同步完成前，集群整体不对外提供服务


对于注册中心，存放了服务实例等数据，这些Server集群间都是存在数据一致性问题的
	Zookeeper  -----CP
	Nacos ------ 默认AP 支持CP
	Eureka ------ AP 
	Consul ------ AP 

AP: 可能存在读取到旧的数据的情况(也可以叫脏读)


************************
provider从配置中心读取配置文件

使用Nacos的控制后台创建配置文件

命名空间
	Data ID : depart-provider.yml 配置文件的文件名需要和spring中配置保持一致
	GROUP : DEFAUT_GROUP
	配置格式: yml
	配置内容 : (支持)直接拷贝yml文件内容

使用：
	之前配置的是 Nacos Discovery 依赖
	现在需要配置 Nacos Config 依赖

依赖配置
	<artifactId>spring-cloue-starter-alibaba-nacos-config</artifactId>

appliaction.yml配置
注意：老版本cloud配置的是 bootstrap.properties / yml
	新版本需要额外添加一个配置指定要读取的nacos文件名

spring:
	application:
		name: depart-provider

	cloud:
		nacos:
			config:
				server-addr: localhost:8848
				file-extension: yml
				username: nacos
				password: nacos

  config:
    import:
      - optional:nacos:${spring.application.name}.${spring.cloud.nacos.config.file-extension}


************************
有关多个微服务共享配置文件的情况
	同一个Namespace 下 同组 下的微服务可以共享的配置 shared（共享）
	任意一个微服务（不同组，不同namespace）都可以共享的配置 extension（扩展）
	一个微服务可以加载多个配置文件

#加载共享文件配置
spring:
	cloud:
		nacos:
			config:
				shared-configs[0]: 
					data-id: shareconfig.yml
					refresh: true
				shared-configs[1]: 
					data-id: shareconfig2.yml
					refresh: true
				extension-configs[0]: 
					data-id: extensionconfig.yml
					refresh: true
				extension-configs[1]: 
					data-id: extensionconfig2.yml
					refresh: true
********
注意：
	当前服务配置、共享配置与扩展配置的加载顺序为：
	先共享配置，然后扩展配置，最后加载当前服务设置

若在三个配置中具有相同属性设置，但他们具有不同的值，那么后加载的会将先加载的给覆盖。
越后加载优先级越高。

优先级
	当前服务配置 高于 扩展配置 高于 共享配置


********
当前服务配置可以存在于三个位置：
	Nacos config服务器中的远程配置文件
	快照文件snapshot（定时更新）
	本地（主动写入的）配置文件

他们的加载顺序为：
	先加载本地配置文件，然后远程配置文件，最后加载快照配置文件

只要系统加载到了配置文件，那么后面的就不再加载


************************
配置文件的动态更新

在Service实现类中，可以使用 @Value注解，读取到application.yml配置文件中的值
	包括自定义的值，也包括云端配置文件中的修改

    @Value("${server.port}")
    private int port;

    @Value("${spring.cloud.nacos.config.password}")
    private String password;


添加配置
depart:
	name: 999

读取
    @Value("${depart.name}")
    private String departName;

启用动态配置更新：
	在类上添加注解，表示该类
	@RefreshScope


************************
多环境选择的实现
	实际开发项目中，通常同一套程序在不同的开发阶段（开发、测试、生产）会被运行在多个不同的环境中。
	在不同的环境中，每一个环境对应的数据库地址，服务器端口号等配置都会不同。
	为了避免大量修改配置文件，容易产生错误。
	需要定义出不同的配置信息，在不同的环境中选择不同的配置，然后借助nacos进行切换。
		（切换数据库，接口，端口号等）


创建多环境配置文件
	在Nacosconfig服务器中克隆对应的配置文件
	修改需要调整的 例如 数据库链接，端口号，账号密码等

切换环境
	修改微服务中的application.yml
	
spring:
  profiles:
  #指定激活的环境（依照命名规范编写）
    active: test
  config:
    import:
      - optional:nacos:${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}

为避免已经打包的程序再编译打包，可以将参数改为动态参数，添加到外部配置文件中。
不过修改了参数就要重新启动应用
	
添加VM options 运行时添加动态参数
	-Dspring.profiles.active=test
	

************************
配置隔离的实现
	使用Namespace  Group  来隔离 DataId  （隔离Service就是服务隔离）

Group的配置 两步
	配置 spring.cloud.nacos.config.group: MY_GROUP  （discovery配的是服务）
	配置 nacosconfig服务器中的配置文件的group: MY_GROUP（克隆或创建配置文件时）

	DEFAULT_GROUP   MY_GROUP

	先匹配命名空间，然后匹配group，然后找到同组下的对应微服务名的配置文件并加载

Namespace的配置 两步
	配置 spring.cloud.nacos.config.namespace: namespaceId
	配置 nacosconfig服务器中的配置文件的namespace: namespaceId（克隆或创建配置文件时）


***************************************************************************************************
OpenFeign与负载均衡
	Spring Cloud OpenFeign

是一种声明式的REST客户端。使用JAX-RS或者SpringMVC的注解修饰，生成接口的动态实现
	OpenFeign的作用就是将提供者提供的Restful服务，伪装 为接口进行消费。
	消费者只需要使用 feign接口 + 注解 的方式，就可以直接调用提供者提供的Restful服务，无需再使用RestTemplate

JAX-RS
	Java Api eXtensions of RESTful webServices
	对与RESTful网络服务的扩展Api
	是JavaEE 6 中的技术
	SpringBoot 3.x中已经升级到JakartaEE
	也是靠注解

OpenFeign的优势：
	只涉及消费者Consumer，与生产者Provider无关。
	相当于一个伪装的客户端，其不会对请求做任何的处理（修改请求体，请求头等）
	也可以理解为伪装的业务接口
	是通过注解的方式实现RESTful请求的

注意：
	OpenFeign和Feign是两个不同的产物
	Feign是由网飞Netflix开发（开源的已经不在维护）
	OpenFeign由社区维护，并捐赠给SpringCloud


********
之前消费者对于微服务生产者的消费使用的是RestTemplate进行的远程调用
	template.delete
	template.put
	等等

消费者调用的是生产者的接口，消费者自身没有多少业务，controller方法与业务关系不大

缺点：
	消费者对提供者的调用无法与业务接口完全吻合，删除，修改等操作没有返回值。
	且代码编写不方便不直观。调用的是url，没有直接通过业务接口调用清晰明确


********
OpenFeign 与 Ribbon
	OpenFeign具有负载均衡功能，其可以对指定的微服务采用负载均衡的方式进行消费，访问。
	老版本的SpringCloud集成的OpenFeign默认采用的Ribbon负载均衡器。
	但是NetFlix已经不再维护Ribbon，故从新版SpringCloud中，已处理Ribbon。
	采用的是 SpringCloudLoadbalancer 负载均衡器


************************
OpenFeign的用法
	消费者使用，只需修改消费者工程的代码

添加依赖
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-starter-openfeign</artifactId>

首先创建伪客户端
	新建service接口，注解 
	@FeignClient("要消费的微服务名称", path="/provider/depart")
	public interface DepartService{
		
	}
	然后编写需要伪装的接口方法，可以直接拷贝controller方法进行修改。
	需要保证RequestMapping路径正确以及参数正确
	注意方法名需要按照service中方法的命名规范重新编写
	添加对应的剩余的请求路径，即 @FeignClient 的 path参数

修改消费者Consumer 的 Controller方法，
	注入伪客户端service
	调用service方法，取代原有的 restTemplate.postForObject() 等

在启动类上添加
	@EnableFeignClients
	开启OpenFeign的伪服务器支持


********
OpenFeign的超时时间设置

application.yml配置

spring:
  cloud:
    openfeign:
	  client:
	    config:
		#全局配置
	      default:
		    #链接超时的设置，主要指consumer连接上provider的时间阈值
		    #对于链接超时，主要影响因素是 网络状态
		    connect-timeout: 1
			#读超时，指consummer发出请求，到接收到provider的响应的这段时间的阈值
			#对于读超时，主要影响因素是 provider的业务逻辑，执行时间
		    read-timeout: 1
		#局部配置
		  depart-provider:
            connect-timeout: 100
            read-timeout: 100

注意：这种default的属于全局配置，该微服务下所有的伪客户端都会使用

局部配置需要指定对应的伪客户端的要消费的微服务名，即"depart-provider"，也就是伪客户端Feign的名称。
@FeignClient(value = "depart-provider", path = "/provider/depart")


********
OpenFeign对请求响应的压缩设置

配置application.yml
	
spring:
  cloud:
    openfeign:
		compression:
		  request:
			#设置启用
		    enabled: true	
			#要压缩的文件类型
			mime-types: ["text/xml", "application/xml", "application/json", "video/mp4"]
			#最小请求大小，针对过小文件越压缩越大的问题
			min-request-size: 1024

		  response:
		    enabled: true


************************
远程调用的底层实现与技术选型

	feign的远程调用，底层实现的默认技术是 JDK 的 URLConnection
	但也支持 httpclient 与 okhttp技术
	restTemplate仍可以在spring中使用

	由于JDK的URLConnection不支持连接池，通信效率低。生产中不会使用该实现

于是在Spring Cloud OpenFeign 中，将默认实现改为 HttpClient，同时也支持OkHttp
	HttpClient支持 hc5

配置：默认
	spring.cloud.openfeign.httpclient.enabled=true
	spring.cloud.openfeign.okhttp.enabled=true

注意：单例模式下，HttpClient的性能更优
	且自定义只能使用 HttpClient


************************
负载均衡及策略更换
	三方
	NacosLoadBalancer
	...
	<spring-cloud-starter-loadbalancer>自带的
	RandomLoadBalancer
	RoundRobinLoadBalancer 轮询 默认
	能用但是策略太少

配置负载均衡Config
public class DepartConfig {
    @Bean
    public ReactorLoadBalancer<ServiceInstance> randomLoadBalancer(Environment e, LoadBalancerClientFactory factory){
        //获取提供者微服务（负载均衡客户端）名称
        String name = e.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        //负载均衡是从所有的伪客户端中均衡，第一个参数是一个List，获取到所有可用的对应名称的提供者
        return new RandomLoadBalancer(
                factory.getLazyProvider(name, ServiceInstanceListSupplier.class),
                name);

    }
}

在启动类上添加注解 @LoadBlancerClients 启用负载均衡
@LoadBalancerClients
@SpringBootApplication
@EnableFeignClients
public class OpenFeignConsumer8080 {
	psvm
}


************************
推荐：开发时使用 DubboSpringCloud 进行负载均衡（消费者调用生产者api时）

	使用Dubbo来做通信客户端
	负载均衡的策略丰富，区分度高，权重也多

	无论使用OpenFeign还是RestTemplate，在进行RPC时，底层都是使用HTTP通信协议。效率较低

	在使用以前的Spring Cloud （NetFlix）时候
	真正底层通信底层协议是 gPRC（谷歌的）

	而Dubbo是十分优秀的Java RPC通信框架，进行RPC时使用的就是自己的Dubbo协议
	Dubbo协议在分布式系统中进行远程服务调用时十分高效的。
	支持负载均衡，容错处理等。
	Dubbo使用ZooKeeper或者Nacos来完成服务注册和发现
	支持无限扩展性！

	淘宝的框架已经迁移到Dubbo上

	springcloudalibaba集成dubbospringcloud使用
	添加依赖 dubbo-spring-boot-starter、dubbo-dependencies


***************************************************************************************************
网关与GateWay

消费者集群 和 生产者集群之间使用nacos进行服务发现，并进行自动负载均衡。
Nacos 提供了几种负载均衡策略，包括随机、轮询、权重等，可以根据具体需求选择合适的负载均衡策略。

而客户端和消费者集群之间，是通过网关来进行链接
网关的一种技术是 （keep alife + VIP）Nginx集群

SpringCloud中采用的网关是 Spring Cloud GateWay

********
网关是整个系统唯一对外的入口，介于客户端和服务器端之间，用于对请求进行鉴权、限流、路由、监控等功能

********
Spring Cloud GateWay 4.0.6
	版本兼容 Spring 6   SpringBoot 3   Project Reactor
	需要使用Spring WebFlix 是基于Reactor的
	支持长链接

GateWay底层实现 Netty
	基于Java NIO实现的，异步，高性能，多协议，安全易用。

无法在传统Servlet容器中使用，也无法打成war包，就是不支持Servlet的
	原来的 HttpServletRequest 也会变为 HttpServerRequest


************************
Reactor
	是全新的，基于ReactiveStreams规范的一套库Library（区别于   RxJava    RxJava2）

响应式编程
	ReactiveProgramming，一种新的编程范式和思想    

响应式编程最早是由 .Net平台上的 Reactive eXtensions（Rx）库
	后来迁移到Java平台，产生了著名的 RxJava
	在此之上为了规范化，产生了 ReactiveStreams 规范

ReactiveStreams是响应式编程的规范，定义了响应式编程的相关接口。
	只要符合该规范的库，就成为Reactive库

RxJava2
	是一个响应式变成库，在ReactiveStreams规范后诞生，
	但由于其实在RxJava上进行的开发，在设计时不仅遵循了ReactiveStreams规范。
	同时为了兼容RxJava，使得RxJava2在使用时非常不方便。
	于是出现了Reactor

Reactor是一种全新的响应式编程库
	完全遵循ReactiveStreams，与RxJava没有任何关系，使用时非常方便直观。
	其中运用了大量的Lambda表达式，简洁，高效，并发性强。


*******
Zuul与GateWay的对比

Zuul是NetFlix的开源API网关，Zuul 1.x是基于Servlet的，使用同步阻塞IO模型，不支持长连接。
	Zuul的效率较低。
	Zuul是SpringClooud生态的一员
	Zuul 2.x 底层使用了Netty，实现了异步非阻塞IO，支持长连接。但是没有被整合到SpringCloud中
		但是Zuul 2.x一开始不开源，并且NetFlix很多开源都已不再维护

SpringCloud GateWay 作为替代品被SpringCloud开发出来，尽管在过程中Zuul2.x又宣布开源
	但是市场，社区对NetFlix开源以及维护失去信心。
	SpringCloud拒绝了集成Zuul
	详见 issue 2951 （2018年的事情）


************************
GateWay
	三大重点：
		route 路由
			路由是网关的基本组成，由一个路由id、一个目标地址url、一组断言工厂、一组filter组成
			若断言为true，则请求将经由filter被路由到目标url

		predicate 断言
			即一个条件判断。根据当前的http请求进行指定规则的匹配，比如http请求头，请求时间等。
			只有当规则匹配时，断言才会为true
			如果匹配失败，则直接返回 404 NotFound
			例如必须携带响应的信息，参数，时间等等
			此时请求才会被路由到目标地址，或者先路由到过滤器链，进行层层处理后，路由到目标地址

		filter 过滤器
			对请求以及响应进行处理的逻辑部分
			当请求的断言为true时，会被路由到设置好的过滤器或过滤器链。
			可以为请求添加一个请求参数，或者对请求URI进行修改，或者为响应添加header等等。


************************
GateWay工作原理简略架构

					GateWayClient（浏览器客户端）
								|
								|
						DispatcherHandler分发器
								|
								|
Spring				Route Predicate Handler Mapping 路由断言处理器映射器
								|
								|
Cloud					Filtering Web Handler
								|
								|
GateWay			preFilter				postFilter
					|						|\
					|/						|
				过滤器链				  过滤器链
								|
								|
						  Proxied Service（目标服务器）
	

************************
路由Route

两种方式
	配置式路由（最常用）    API式路由

引入Spring Cloud GateWay
	引入依赖
		<artifactId>spring-cloud-starter-gateway</artifactId>
	并且要删除掉引入servlet的web依赖
		<artifactId>spring-cloud-starter-web</artifactId>

配置application.yml（配置式路由）
spring:
  cloud:
    gateway:
      routes:
        - id: bd_route
          uri: https://baidu.com
          predicates:
            - Path=/bd
        - id: tb_route
          uri: https://taobao.com
          predicates:
            - Path=/tb
        - id: jd_route
          uri: https://jd.com
          predicates:
            - Path=/jd

指定 
	路由的id，url以及对应的断言 predicates

流程
	先到Dispatcherhandler分发器，根据请求，
	分发到响应的Route Predicate Handler Mapping 路由断言处理器映射器


********
API式路由	
						
需要手动配置 @Configuration 修饰的 Configure 类，提供路由定位器 RouteLocator
	其中编写所需的route id api predicates

    @Bean
    public RouteLocator bdRouteLocator(RouteLocatorBuilder builder){
        return builder.routes()
                .route("bd_route",
                        ps -> ps.path("/bd")
                                    .uri("https://baidu.com"))
                .route("jd_route",
                        ps -> ps.path("/jd")
                                .uri("https://jd.com"))
                .build();
    }


********
复习 函数式接口
Spring中 通过注解 @FunctionalInterface，将函数式接口纳入管理

函数式接口 有且只有一个抽象方法，并通常会提供默认实现


************************
断言工厂 Predicate Factory

共十二种路由断言工厂

After  
Before  
Between  
Cookie  
Header  
Host  
Method  
Path Route
Query Route
RomoteAddr
Weight Route
XForwarded Remote Addr Route

一个predicates下可以写多个断言工厂

predicates:
  - After=
  - Cookie=
  - Header=
  - Header=
  ...


********
After 和 Before 路由断言工厂（时间上的判断）

配置式（最常用）
spring:
  cloud:
    gateway:
      routes:
        - id: my_route
          uri: http://localhost:8081/
          predicates:
            - After=2020-01-01T10:10:10.100-07:00

API式

	ZonedDateTime dateTime = LocalDateTime.now().minusDays(10).atZone(ZoneId.systemDefault());

      return builder.routes()
                .route("tb_route",
                        ps -> ps.before(dateTime)
                                .uri("https://taobao.com"))
                .build();

After表明在该时间之后，路由断言为真。
Before表明在该时间之前，路由断言为真

应用场景：拦截某一时间之前或之后的请求等，限时开启售卖，限时签到等


********
Between 路由断言工厂

表明在两个给定的时间之间   ，路由断言为真。

	- Between=A,B

	ps.between(A, B)

应用场景：限定一个区间内时间的请求，例如电商限时促销


********
Cookie 路由断言工厂

Cookie即为一个键值对

	- Cookie=city,beijing

	ps.cookie("city", "beijing")

使用API Tester，Postman等工具，测试发送请求，携带cookie。
	注意：需要避免浏览器软件禁用cookie的情况（谷歌的chrome在80左右的版本已升级为token），

Key							Value

Cookie						city=shanghai


********
Header 路由断言工厂

可以匹配正则表达式

	- Header=X-Request-Id, \d+
	- Header=Color, gr.+

	ps.header("X-Request-Id", "\\d+")
	  .and()
	  .header("Color", "gr.+")


************************
配置文件中，一个predicates下写的 路由断言 之间是 与 的关系，对应 and()
			不同predicates下写的 路由断言 之间是 或 的关系，对应 or()


************************
复习
自定义Error全局异常处理器
	处理404异常页面 status=404

********
注意这是 ErrorWebExceptionHandler 全局处理，
	普通的响应式编程下的异常处理是WebExceptionHandler管理
	管理一些函数式端点中的异常
	它处理的后台异常是报500，再由前者进行处理，渲染 randerRouteFunction等等进行响应

区别于SpringMeb， GateWay不支持Servlet，不走之前那一套ExceptionHandler了

异常会交由 DefaultErrorWebExceptionHandler 处理
	继承自抽象类 AbstractErrorWebExceptionHandler
	方法的参数也都是 ServerRequest request     ServerResponse reposne等

核心方法

	@Override
	protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {
		return route(acceptsTextHtml(), this::renderErrorView).andRoute(all(), this::renderErrorResponse);
	}

********
自定义Error全局异常处理器需要继承 AbstractErrorWebExceptionHandler
	并实现该核心方法 getRoutingFunction

@Component
@Order(-1)
public class CustomErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {
    /**
     * 为构造方法提供合适的参数（框架注入）并提供Readers和Writers
	 * super调用父类构造完成初始化
     */
    public CustomErrorWebExceptionHandler(ErrorAttributes errorAttributes,
                                          ApplicationContext applicationContext,
                                          ServerCodecConfigurer serverCodecConfigurer) {
        super(errorAttributes, new WebProperties.Resources(), applicationContext);
        super.setMessageReaders(serverCodecConfigurer.getReaders());
        super.setMessageWriters(serverCodecConfigurer.getWriters());
    }

    /**
     * 核心方法 getRoutingFunction
     * 使用RouterFunctions的route方法，获取RouterFunction<ServerResponse>
     * RequestPredicates.all() 返回true
     * 自定义核心：
     * 重写handlerFunction，提供自定义的处理方法 renderCustomErrorResponse，
     *
     * @param errorAttributes the {@code ErrorAttributes} instance to use to extract error information
     * @return a {@link RouterFunction} that routes and handles errors
     */
    @Override
    protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {
        return RouterFunctions.route(RequestPredicates.all(), this::renderCustomErrorResponse);
    }

    /**
     * 自定义异常处理，转换为json格式，插入响应体，并响应给前端
     * status 指定状态码为 404
     * contentType 指定响应数据
     *
     * @param request ServerRequest
     * @return Mono<ServerResponse> 是SpringWebFlux中，响应返回的对象，可以类比WebMVC中的ResponseEntity<T>
     *     其中泛型都代表body，信息数据存储在响应体中
     */
    private Mono<ServerResponse> renderCustomErrorResponse(ServerRequest request) {
        //获取异常信息，此处可以自定义获取的内容。可以重写 getErrorAttributes方法，自定义获取的数据
        Map<String, Object> errorAttributes = getErrorAttributes(request, ErrorAttributeOptions.defaults());
        //构建响应
        return ServerResponse.status(HttpStatus.NOT_FOUND)
                            .contentType(MediaType.APPLICATION_JSON)
                            .body(BodyInserters.fromValue(errorAttributes));
    }
}

得到的返回json是
{
    "timestamp": "2024-07-04T07:26:13.755+00:00",
    "path": "/",
    "status": 404,
    "error": "Not Found",
	"messasge": "null"
    "requestId": "ef6d581d-1"
}
即可交由前端Vue进行解析

********
在自定义异常处理中，可以重写getErrorAttributes方法，对于要获取的数据进行自定义
	继承 reactive包的 DefauleErrorAttributes

@Component
public class CustomErrorAttributes extends DefaultErrorAttributes {
    @Override
    public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
        //获取父类中提供的 基础的map
        Map<String, Object> map = super.getErrorAttributes(request, options);
        //对数据进行自定义，在put到map中
        map.put("msg", "未找到相关资源");
        //返回map。map会被框架自动转换为json格式
        return map;
    }
}

对 ErrrorAttributes map中的数据进行自定义，增删改
当然也可以完全自定义一个全新的map进行返回


********
Host 路由断言工厂

判断条件是主机的host地址
	例如 127.0.0.1 aaa.com:9000
注意，端口号必须提供

	- Host=aaa.com:9000, bbb.com:9000

	ps.host("aaa.com:9000", "bbb.com:9000")

可以用来地理地区分流，用户权限分级等
	

********
Method 路由断言工厂

判断方式是 请求提交的方式

	- Method=POST, GET

	ps.method("POST", "GET")


********
Path 路由断言工厂

判断请求路径是否匹配

	- Path=/provider/**

	ps.path("/provider/**")


********
Query 路由断言工厂

判断请求url中携带的参数是否匹配
书写多个条件就需要传递对应数量的参数
	?color=green
	
	- Query=color, gr.+
	ps.query("color", "gr.+")


********
Weight 路由断言工厂
	权重 
分配复数请求，依照权重的比例路由分发到不同的uri
（电商 ecommerce ）

如下配置即为 20%到淘宝，80%到京东

        - id: tb_route
          uri: https://taobao.com
          predicates:
			- Weight=ecommerce, 2
        - id: jd_route
          uri: https://jd.com
          predicates:
			- Weight=ecommerce, 8

使用场景：灰度发布（部署上线新版本时候先让部分请求引流过去），也叫做金丝雀发布，AB测试
			同时保持旧的服务依旧稳定。在新服务发现实际生产问题即可对应解决。降低影响面。
			例如及时回滚，
			配合上Nacos的动态配置管理，就可以完成动态权重配置。逐渐稳步安全增加新版本的权重，
			直到完全取代老版本

********
配置式路由断言工厂 和 API式路由断言工厂 的优先级

（SpringBoot的启动类也是一个Config类 @SpringBootApplication 
编写配置 @Configuration 的，图快可以直接丢到Starter下）

若用两种配置方法，配置了相同种类的路由断言工厂，比如都是 Header Query Cookie等路由断言工厂
判断条件取并集，他们之间是 或 的关系。

时间类的After Before Between 若配置了互相矛盾的条件，
则配置文件的优先级更高

生产环境下，配置文件交由Nacos管理，修改配置文件比较方便


************************
自定义路由断言工厂

API简介

路由断言工厂的共同父类 抽象类 AbstractRoutePredicateFactory<C> implements RoutePredicateFactory<C>
	目前共14个实现 After Before Between 路由断言工厂 。。。
	对应的泛型就是对应实现的工厂的配置，例如
	public class AfterRoutePredicateFactory extends AbstractRoutePredicateFactory<AfterRoutePredicateFactory.Config>{}


自定义则需要继承此抽象类，并重写 RoutePredicateFactory 中的核心方法
	Predicate<ServerWebExchange> apply(C config);
	
ServerWebExchange 可以理解为 server-side 的 HttpRequest和HttpResponse的上下文，是非常重要的一个接口
	public interface ServerHttpRequest extends HttpRequest, ReactiveHttpInputMessage {
	注意不是servlet的
	方法：
	ServerHttpRequest getRequest();
	ServerHttpResponse getResponse();
	Map<String, Object> getAttributes();
	Mono<WebSession> getSession();
	Mono<MultiValueMap<String, String>> getFormData();
	Mono<MultiValueMap<String, Part>> getMultipartData();
	。。。
可以用来获取响应，请求，会话，参数，携带的数据等等

其中包含了自定义所需的核心方法 mutate()
	default Builder mutate() {
		return new DefaultServerWebExchangeBuilder(this);
	}

	interface Builder {
		Builder request(Consumer<ServerHttpRequest.Builder> requestBuilderConsumer);
		Builder request(ServerHttpRequest request);
		Builder response(ServerHttpResponse response);
		Builder principal(Mono<Principal> principalMono);
		ServerWebExchange build();
	}


************************
自定义 Auth 认证

需求：当请求头中携带有用户名与密码的 key-value 对，且其用户名与配置文件中 Auth 路由断言工厂中
	指定的 username 相同，密码中包含Auth路由断言工厂中指定的 password 时才能通过认证，允许访问

首先：自定义Factory
	规范：类名由两部分构成，后缀必须是 RoutePredicateFactory，前缀为功能Auth，会用在配置文件中
	即为 AuthRoutePredicateFactory
	配置
		predicates:
         -Auth=zhangsan, 123
	
然后继承 AbstractRoutePredicateFactory<AuthRoutePredicateFactory.Config>

新建内部静态类Config，用于接收配置文件中读取的配置信息

重写shortcutFieldOrder方法，设定读取配置的顺序
	return Arrays.asList("username", "password");

       predicates:
         -Auth=zhangsan, 123
      就会将 zhangsan读取为 username
           123 读取为 password
      必须保证顺序，否则读取会出错
	框架采用的时set注入，必须提供set方法且保持一致

然后提供无参构造

然后实现核心方法 apply
	返回 断言 Predicate<ServerWebExchange>
	Predicate是一个函数式接口，其中有且只有一个抽象方法 boolean test(T t) 返回布尔值

	判断用户名和密码是否匹配
		Lambda写法
        return exchange -> {
            //获取请求中所有的header
            HttpHeaders headers = exchange.getRequest().getHeaders();
            //获取配置中所指定的header，注：一个请求头可以包含多个值所以是List
            List<String> passwords = headers.get(config.getUsername());
			//避免NPE
            assert passwords != null;
            return passwords.contains(config.getPassword());

        };

		普通写法
        return new Predicate<ServerWebExchange>() {
            @Override
            public boolean test(ServerWebExchange serverWebExchange) {
                //获取请求中所有的header
                HttpHeaders headers = serverWebExchange.getRequest().getHeaders();
                //获取配置中所指定的header，注：一个请求头可以包含多个值所以是List
                List<String> passwords = headers.get(config.getUsername());

                assert passwords != null;
                return passwords.contains(config.getPassword());
            }
        };

前端API测试  携带 header     zhangsan    123
	只要携带的header中，value为zhangsan的有一个值为123，即可通过上述自定义Auth路由断言工厂

注意：List<String> passwords = header.get(config.getUsername())   有可能获取的是 被拼接合并后的字符串 只剩下了一个元素


************************
自定义 Token 认证

区别于上述的 auth认证，需要两个参数。Token认证只需要一个参数
- Token=123456

需求：当请求中携带 由一个token参数，且参数值包含在配置文件中Token路由断言工厂指定的token值中 时
	验证通过，允许放行。
	即携带可以携带多个，只要有一个匹配上，即可放行


************************
RemoteAddr路由断言工厂

********
本机192.168.1.5
Linux192.168.1.2
(win命令 netstat -o 查端口)
命令：
curl http://192.168.1.5:8081/provider/depart/addr
（url添加请求参数 请求末尾 ?key=value&key=value）
（url添加请求头 --header "key:value" ）
（url添加Cookie --cookie key=value ）

使用linux服务器，访问本地项目provider，输出remoteAddr， remotePort，LocalAddr，LocalPort

remoteAddr=192.168.1.2
remotePort=52810
localAddr=192.168.1.5
localPort=8081

如果是运行win10系统（上的虚拟机跑linux）则外部地址则是win10系统名（与本地的ip地址相同）
	因为win10系统会 自动充当 运行在系统上的应用的 反向代理

RemoteAddr是指外部地址，RemotePort是指外部端口号

********
IP地址共有五类 A B C D E
	我国没有A类，都在米国
	我国持有少量B类地址
	我国主要的是C类地址
目前IPv4地址已经耗尽，于是出现了子网掩码，即 192.168.1.1/24
	IP地址共32位
	这种表示方式叫做 点分十进制IP
	/24 表示前面24位表示网段
		后面8位表示主机ID

断言工厂配置，就是访问白名单
	predicates:
	  - RemoteAddr=192.168.1.1/24, 192.168.192.105

	192.168.1.1/24表示 192.168.1.2 到 192.168.1.254 都可以访问


************************
XForwardedRemoteAddr路由断言工厂

上述RemoteAddr，获取远程地址存在弊端，因为请求可能经过很多个服务器，反代等。无法获取准确的外部地址。

使用 X-Forwarded—For 可以获取请求过程中的地址
	原理，是一个字符串，途径一个就追加到后面。最后一个是远程地址

此断言的判断条件只是判断最后一个远程ip，与发出请求的，最后接受请求的，前面路径的都无关
	只与 最后一个 被记录到 X-Forwarded-For 上的ip地址有关

	predicates:
      - XForwardedRemoteAddr=192.168.1.1/24

API测试，添加headers
	X-Forwarded-For    192.168.1.88
	X-Forwarded-For    192.168.1.234


************************
GateWay的过滤器工厂
	GateWayFilterFactory

	允许以某种方式修改传入的HTTP请求或返回的HTTP响应，其作用域是某些特定路由。
	Gateway包含了很多内置的网关过滤器工厂，也可以进行自定义。


************************
AddRequestHeader 网关过滤工厂（GatewayFilterFactory）
	作用 添加请求头，一次只能添加一个
		添加多个就写多个AddRequestHeader

配置式：
          filters:
            - AddRequestHeader=X-Request-Color, orange
            - AddRequestHeader=X-Request-Color, black
            - AddRequestHeader=X-Request-Color, white

API式：
	在原有GateWayConfig类中追加

	return builder.routes()
				.route("my_route",
						ps -> ps.path("/**")
								.filters(fs -> fs.addRequestHeader("X-Request-Color", "orange")
												 .addRequestHeader("X-Request-Color", "black")
												 .addRequestHeader("X-Request-Color", "white"))
								.uri("http://localhost:8080"))
				.build();

对于多个filter并列，他们之间的关系是 与。
	即全都添加上，默认顺序是 由上到下依次添加header。


************************
AddRequestHeadersIfNotPresent 网关过滤工厂
	作用：添加请求头，一次可以添加多个
	条件：没有出现过的，已经添加过的值不再添加，不去覆盖
	如果前面已经出现已经有值，则后出现的不会去赋值导致覆盖。
	一个key只会有一个value

配置式：
	filters:
	  - AddRequestHeadersIfNotPresent=X-Request-Color:orange, X-Request-Color:black, city:beijing

对于从 request 中提取 header
	可以先获取所有header的key  getHeaderNames()
	遍历key，依次取出所有key所对应的所有value
	while (headerNames.hasMoreElements()){
		String name = headerNames.nextElement();
		Enumeration<String> headers = request.getHeaders(name);
		sb.append(name).append(":");
		while(headers.hasMoreElements){
			sb.append(headers.nextElement()).append(", ");
		}
		sb.append("<br>")
	}

当然spring框架可以直接接收请求中携带的参数，并注入到方法的参数列表中
	如果已知参数名，类型。可以直接接收。


************************
AddRequestParamter 网关过滤工厂
	作用：添加请求参数 Param

配置式：
	filters:
	  - AddRequestParamter=color, red
	  - AddRequestParamter=color, green
	  - AddRequestParamter=city, shanghai

从request中取出parameter
	Map<String, String[]> parameterMap = request.getParameterMap();
	增强for遍历所有key
		增强for遍历所有value
			sb.append();
	return sb;


************************
AddResponseHeader 网关过滤工厂
	作用，添加响应头

配置式：
	filters:
	  - AddResposneParamter=color, red
	  - AddResposneParamter=color, green


************************
CircuitBreaker 网关过滤工厂
熔断器
	
	作用：在高并发场景下，服务器出现问题可能导致服务雪崩
		服务降级，避免服务雪崩发生

使用：添加依赖
	spring-cloud-starter-circultbreaker-reactor-resilience4j

配置式定义：
		  filters:
			#名称固定
            - name: CircuitBreaker
              args:
                name: myCircuitBreaker
				#指定熔断后要降级到的页面
                fallbackUri: forward:/fb

在响应式编程中，函数式接口
	Provider 是只出不进，不需要参数但有返回值
	Function 是有出有进，需要参数也有返回值
	Consumer 是只进不出，需要参数但没有返回值

API式：
	return builder.routes()
				.route("my_route",
						ps -> ps.path("/**")
								.filters(fs -> fs.circuitBreaker(config -> {
									config.setName("my_circuitBreaker");
									config.setFallbackUri("forward:/fb");
								}))
								.uri("https://www.jd.com"))
				.build();


************************
PrefixPath 网关过滤工厂
添加前缀
	作用：自动给请求提交的uri添加前缀

配置：
	routes:
	  - id: my_route
	    uri: http://localhost:8081
		predicates:
		  - Path=/depart/**
		filters:
		  - PrefixPath=/provider

原有应该提交的：localhost:9000/provider/depart/list
实际应该提交的：localhost:9000/depart/list


************************
StripPrefix 网关过滤工厂
移除前缀
	作用：自动给请求提交的uri删除前缀，需要指定移除的前缀数量
	前缀是以 \ 划分

配置：
	routes:
	  - id: my_route
	    uri: http://localhost:8081
		predicates:
		  #路径需要匹配，匹配全部比如 /*/*
		  - Path=/xxx/ooo/provider/depart/**
		filters:
		  - StripPrefix=2

实际应该提交的：localhost:9000/xxx/ooo/provider/depart/list


************************
RewiritePath 网关过滤工厂
重写路径
	作用：将uri进行重写（替换）

配置：
	routes:
	  - id: my_route
	    uri: http://localhost:8081
		predicates:
		  - Path=/red/**
		filters:
			#可以编写正则来匹配，替换
		  - RewritePath=/red/blue, /provider/depart

正则举例：
	filters:
	  -RewritePath=/red/?(?<segment>.*), /$\{segment}
	含义为：去掉 /red 前缀
	正则可以储存参数，并应用到下个正则
	这种写法叫正则分组 (?<segment>.*) ，segment是分组名称，${segment}引用组中参数
	$\ 的写法 代替 $ 是yaml的规范格式
	如果使用api式编写，写在双引号中，则需要 $\\ 转译为 $


************************
令牌桶算法

每过一个时间单位（per tick 可控）向令牌桶中添加一个（可控）令牌，（令牌桶满则不生成令牌）

请求过来时，先看队列 Queue满没满。满了就discard丢弃，没满则加入队列。

处理请求要从队列中拿取队首元素（对应的请求）

每一个请求，拿一个令牌，从桶中移除该令牌。

持有令牌的才可以进入下一步（此处通过令牌来限制流量）

处理器 Processor 对请求进行处理，然后请求离开 Departure

限流原理：
	令牌桶中令牌的数量，添加的速度。
		如果请求来的速度，大于向令牌桶添加令牌的速度，就会导致请求挤压在队列中
	队列的大小
		队列如果满了，就会拒绝请求进入，起到限流作用

	相当于控制添加令牌的速度，就控制了请求处理的速率


************************
漏斗算法
	泳池放水加水问题

	主体是一个有洞的水桶，水桶有个洞，里面的水以恒定的速度向外滴水

	过来的请求，经过队列被拿到后，需要拿到一个水滴，才可以被服务器处理

	水滴是以一种恒定的速度提供。难以改变。

令牌桶算法可以通过改变令牌生成速度，与提高令牌桶容量的办法
	可以处理突发流量暴增的请情况。


************************
RequestRateLimiter 网关过滤工厂
请求限流
	使用 RateLimiter 限流算法来判断是否当前的请求是允许的。
	不允许则报 429 - Too Many Requests

RateLimiter有很多实现，一种实现是 The Redis RateLimiter 使用Redis实现限流
	添加依赖 spring-boot-starter-data-redis-reactive

默认实现是采用的令牌桶算法 Token Bucket Algorithm

********
限流需要限流键 key

限流键的配置

    @Bean
    KeyResolver userKeyResolver() {
        return exchange -> Mono.just(Objects.requireNonNull(
                exchange.getRequest().getQueryParams().getFirst("user")));
    }































Data Management Service













































































































































































































































































